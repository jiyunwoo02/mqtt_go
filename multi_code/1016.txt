1016 피드백

[브로커]
# 1. 명령행 인자 입력 시 -port=1884 나 1884 나 동일하게 동작하나? 그렇거나, 그렇지 않다면 왜?
.\broker.exe -port=":1883" -id="bro1"와 ./broker.exe 1883 bro1 는 동일하게 동작하나?
-> 동일하게 동작한다. 그러나, 기본값을 생각해야 한다.
: 사용자가 명령행에서 -port나 -id를 입력하지 않으면, 기본값이 사용된다.

해당 코드에서는 사용자가 명령행 인자로 -port="1883"와 같은 형식으로 입력할 수도 있지만, 
입력을 하지 않을 경우에도 기본값(default)이 설정되어 브로커가 실행되도록 되어 있다.

그래서 옵션명을 명시하지 않고, 
.\broker.exe 혹은 .\broker.exe 1884 bro2 로 브로커를 구동하려 하면,
해당 경우는 명령행에서 -port와 -id를 (플래그를) 지정하지 않은 경우로 간주되어
-> 옵션명(-port, -id) 없이 값만 전달하면 파싱되지 않는다
-> 기본값이 그대로 사용된다: port = ":1883", brokerID = "broker1"

즉, 이 코드는 -port와 -id 플래그를 사용해야 한다. 
-> 플래그 형식으로 -port="1883"처럼 입력해야만 명령행 인자가 올바르게 전달된다.
플래그를 입력하지 않으면 기본값(:1883, broker1)으로 실행된다.

os.Args처럼 순서에 의존하지 않으며, 플래그 이름을 통해 정확하게 값을 매핑할 수 있는 장점이 있다.

# 2. startBroker 함수는 인자를 두 개 받아 구동한다. 이는 문제가 되지 않는다. 
그런데 명령행 인자의 순서를 바꿔 입력하면 어떻게 되나?
: Go의 flag 패키지는 명령행 인자를 파싱할 때, 인자의 순서와 무관하게 작동한다. 
- 옵션 이름(플래그 이름)을 기반으로 인자를 식별하기 때문
- 순서와 상관없이 이름에 따라 값을 찾기 때문에 명령행 인자 순서가 중요 X
-> 즉, 명령행에서 플래그가 어떤 순서로 입력되든, 프로그램은 옵션 이름을 보고 적절한 값을 매핑

- 명령행 인자 파싱 -> 플래그 이름이 일치하는 인자는 대응되는 변수에 할당
- flag 패키지는 각각의 인자를 독립적으로 처리, 순서가 바뀌더라도 문제가 없다.

+) 순서와 상관없이 플래그를 옵션과 함께 사용 -> go run broker.go -id="myBroker" -port="1885" = 정상 작동

# 2-0. flag와 args의 인자 식별 방법
: os.Args는 단순히 띄어쓰기를 기준으로 인자를 나눈다, 띄어쓰기를 기준으로 각 인자가 배열에 저장됨
: flag 패키지는 플래그 이름과 값으로 명령행 인자를 구분 (-플래그이름=값 또는 -플래그이름 값), -로 시작하는 플래그 이름과 그 뒤의 값이 짝을 이루어 사용

# 2-1. 코드 내에서 string(데이터 타입)과 String(메서드)의 차이

# 3. 메인 함수의 처음부터 len(내장함수)을 사용한다. 그렇다면 Args에 이미 데이터가 저장되어 있는 것인가?

# 4. a := b 에서 a에 b를 넣는 것인지에 대해 파악하라.

# 5. select {}은 어떤 의도로 작성한 것인가?

# 6. 메인 함수의 처음부터 Args의 문자열 배열의 요소를 각각 출력하라.

# 7. Scanner에 대해 이해하라. 왜 Scan() 후에 Text()를 사용하는가?

# 8. 코드 내에서 break는 어떻게 작동하나?

# 9. TrimSpace를 메인함수로 이동시켜라. 앞뒤 공백을 제거하도록 해라.

# 10. token의 Wait()는 어떻게 동작하는가? bool 타입인데 언제 true와 false를 반환하는가?