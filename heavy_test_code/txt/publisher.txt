
[코드 전체 로직]

- MQTT 발행자(Publisher) 역할을 수행하며, MQTT 브로커와 소켓 연결을 통해 메시지를 발행하고 전달
- 사용자는 명령행 플래그로 발행 설정을 입력하고 메시지를 반복 발행

---

1. 명령행 플래그 파싱
- 발행자 ID, QoS 값(0~2), 발행할 메시지 횟수, 소켓 리슨 포트를 명령행에서 입력받아 설정
- 잘못된 QoS 값이 입력되면 프로그램 종료

---

2. MQTT 브로커 연결
- MQTT 브로커와 연결해 발행할 준비

---

3. 소켓 서버 설정 (옵션)
- 소켓 서버는 제공된 포트로 구독자와 연결
- 포트가 없으면 소켓 서버는 시작하지 않음

---

4. 사용자 입력 메시지 수집 및 처리
- 사용자가 발행할 메시지를 입력받음
- exit 입력 시 메시지 발행 종료

---

5. 메시지 발행
- MQTT 브로커와 소켓을 통해 메시지를 반복 발행
- 각 메시지는 `<메시지>#<순서>` 형식으로 발행

---

6. 프로그램 실행 유지
- 프로그램이 종료되지 않고 구독자와의 연결을 유지

---

[결과 요약]
- MQTT 브로커와 소켓 연결을 통한 메시지 발행이 수행
- 사용자는 메시지 내용과 반복 횟수를 입력하며, 메시지가 발행될 때마다 콘솔에 출력
- 구독자가 연결된 경우, 소켓으로도 동일한 메시지를 전달

[log.Printf와 fmt.Printf의 차이점]
: fmt.Printf는 단순한 메시지 출력을 위해 사용하고,
: log.Printf는 로그나 에러 메시지 관리에 더 적합하다.

특징			fmt.Printf			log.Printf
출력목적		일반 메시지 출력	  로그 메시지 출력
시간정보포함	 X				     O
용도			콘솔 출력			 에러 처리, 디버깅, 로그 관리
출력대상		표준 출력 (stdout)   로그 (stdout 또는 파일)

예) fmt.Printf("Hello, %s!\n", "World") -> Hello, World!
예) log.Printf("An error occurred: %v", err) -> 2024/10/28 17:45:33 An error occurred: <error message>


[log.FatalF는?]
: 형식화된 메시지를 출력한 후 프로그램을 종료하는 함수
: 내부적으로 log.Printf를 사용해 메시지를 출력한 뒤, os.Exit(1)을 호출하여 프로그램을 비정상 종료

-> log.Printf와 동일하게 형식화된 메시지를 출력, 시간 정보 포함, 복구 불가능한 오류 발생 시 메시지 출력 후 프로그램 강제 종료

// 사용자로부터 발행할 메시지 입력 받기
scanner := bufio.NewScanner(os.Stdin) // 표준 입력(키보드)으로부터 데이터를 읽기 위해 스캐너 생성
fmt.Print("Enter the message to publish: ") // 입력 요청 메시지 출력
scanner.Scan() // 사용자가 입력할 때까지 대기, 입력 후 엔터 키 입력 시 데이터 읽음
message := scanner.Text() // 사용자가 입력한 내용을 문자열로 저장

1. os.Stdin (표준 입력): 키보드 입력을 받을 수 있는 표준 입력 스트림.
- 프로그램이 실행되는 동안 키보드로부터 입력을 받을 수 있는 표준 입력 스트림
- os.Stdin을 통해 사용자가 입력한 데이터를 읽는다.

2. bufio.Scanner (버퍼 기반 스캐너): 입력을 줄 단위로 처리하는 스캐너.
- os.Stdin에서 입력을 줄 단위로 읽기 위해 bufio.Scanner를 사용
- 엔터 키가 눌릴 때까지 입력을 대기하고, 입력된 데이터를 내부 버퍼에 저장

3. scanner.Scan() (사용자 입력 읽기):
- 사용자가 엔터 키를 누르면 Scan()이 입력된 데이터를 읽어 들인다.
- 데이터가 정상적으로 읽히면 true를, 실패하면 false를 반환

4. scanner.Text() (입력된 텍스트 가져오기):
- 사용자가 입력한 데이터를 문자열 형태로 반환
- 이 값을 message 변수에 저장
